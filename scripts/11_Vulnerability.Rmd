---
title: "Looking at mound Vulnerability"
author: "Adela Sobotkova"
date: "28 July 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**I was not sure of how to comment this in a visible way, or whether or not I was allowed to change the code, so this is the system I ended up develdoping:** 
**I will write in this font when I have a comment, or when code had to be edited to work on my machine.**
**When code is edited, I will comment the code that didn't work and paste an edited version below.**
**While I have made some comments on the text, I have not read it closely enough to make proper corrections. Tell me If you want me to do so. **

## Methodology
We apply an ordered logit model to determine the vulnerability of burial mounds to anthropogenic threats in the Yambol province. This model has been developed in a previous study of the Kazanlak Valley in central Bulgaria. However, as the study areas differ in their location, environment, as well as level of development, we expect to see differences in mound vulnerability and predicted decline. While field observations underscored looting as a massive factor, subjectively looting felt less intense in Yambol than in Kazanlak (Eftimoski et al. 2017). Agricultural and military activity (due to proximity to Cold War border) competed for place among the principal factors contributing to the ubiquitous degradation of the mounds we saw during archaeological surveys (Sobotkova and Weissova 2020). Choosing these factors over others constituted a ‘perceptive’ initial risk assessment (Vojinovic et al. 2016). 

Based on this intuition, we propose a number of hypotheses:

1. The ploughing, harrowing, and removal of obstacles from fields associated with annual agriculture damage mounds, so conversion FROM other land-use type TO annual agriculture would tend to damage mounds more (increase the Condition score where 1= pristine, 5 = near extinct).
2. Proximity to national border formerly the cold-war border will increase mound damage due to their remake as bunkers. Ie. map symbols indicating mounds will turn out to be bunkers and other defensive features in the field.  
3. Proximity to a city, town, or village would contribute to damage, since it is a proxy for destructive peri-urban activities like development, construction and casual looting (cf. Agapiou et al. 2015).
4. Looters would preferentially target larger mounds and inflict greater archaeological damange (ArchaeologicalImpact) and lesser volume damage(CRM column), since large mounds typically contain richer burials than small ones. We concede that small mounds are more susceptible to agricultural damage, but thought that damage to large mounds from looting would prove more significant (cf. Stone 2008, 67-68).
5. Looters operate in a spatially contiguous area and mound condition will be spatially correlated.

The analysis here will test our subjective perceptions of risk. We use a relatively large number of observations (ca 1000) to model relationships between mound condition and elevation, mound size, surrounding land use (including annual agriculture, perennial agriculture, pasture, or forest), and distance to the nearest urban and national boundary. 
Five specific changes were then simulated:
- conversion of all forest to annual agriculture;
- conversion of all forest to pasture;
- conversion of all pasture to annual agriculture;
- an increase in distance of one standard deviation (XXX m) from the nearest edge of a city, town, or village.
- an increase in distance of one standard deviation (XXX m) from the southern border / southern aspect / location in 30m border zone?
- regression of Condition over Height (or other proxy of size)
- spatial autocorrelation of Condition is tested (location or relief?)
**The last two points do not make sense on the list as they are not simulations**


## Landuse

‘Land-use’ represents how land was used around the mound at the time of survey with categorical values of pasture, forest, annual agriculture (arable land), perennial agriculture, scrub, and urban (Fig. 4). Mounds were most frequent in agricultural fields, which [comprised XXX% of the Yambol province (XX of 3355 km2), and ] contained 54.2% of the mounds (640). Conversely, grasslands - whether pastures or overgrown field-divisions - [comprised YYY% of the Yambol province (XX of 3355 km2), but] contained 30.4% of the mounds (359). Scrub surrounded 8.6% mounds (101) , while all the remaining landuse categories together contained the remaining 6.5% of mounds (80). 

Qualify! [Put another way, the density of mounds per sq km was high in pasture, but low in annual agriculture (26.9 vs 2.3 respectively). Any change from pasture to annual agriculture, therefore, may affect a large number of mounds. Scrub and Perennial agriculture were retained in the model to improve estimation of logit coefficients (see 2.3 below), but no attempt was made to simulate land-use transitions on such a small number of mounds (n=99 and 15 respectively). The remaining types of Forest (n=52), and Other (n = 11) can be grouped under ‘Other’ in Fig. 4) due to their low incidence (less than 15% of all mounds altogether).


```{r, echo = FALSE}
library(tidyverse)
library(sf)
```
# Let's review the dataset
**Changes were made to this code-chunk**
```{r data}

# Load in the master_sp from shapefile or inherit from 07_EnrichSpatial.R
# master_sp <- st_read("../output_data/enriched_all.shp") 
# The file-path of the code above is does not work. instead, this should work:
master_sp <- st_read("../data/enriched_all.shp")

# Liberal dataset
master_sp %>%
  group_by(Type) %>%
  tally()

# Most conservative dataset
master_sp %>% 
  filter(Type == "Burial Mound" | Type == "Extinct Burial Mound") 
```



# Fixing landuse 

Lets review the most common categories of landuse AROUND mounds

**Changes were made to this code-chunk**
```{r}
# master_sp %>% 
#   st_drop_geometry() %>% 
#   filter(Type == "Burial Mound" | Type == "Extinct Burial Mound") %>%   group_by(LU_Around) %>% 
#   tally() %>% 
#   mutate(perc = round(n/sum(n)*100, 2)) %>%  # this will not run after I once have spread it.
#   arrange(desc(n))

# The variable LU_Around does not exist yet - In the code below I have eddited it

master_sp %>% 
  st_drop_geometry() %>% 
  filter(Type == "Burial Mound" | Type == "Extinct Burial Mound") %>%   group_by(LU_Arnd) %>% 
  tally() %>% 
  mutate(perc = round(n/sum(n)*100, 2)) %>% 
  arrange(desc(n))

```
 Annual agriculture, pasture and scrub are the most common categories, with forest perhaps the last meaningful category. Perennial agriculture, other and urban might be best merged into Other, or perennial with agriculture and the rest in Other. 
 
 The situation with landuse ON TOP of mounds looks similar.
```{r}
master_sp %>% 
  st_drop_geometry() %>%
  filter(Type == "Burial Mound" | Type == "Extinct Burial Mound") %>% 
  group_by(LU_Top) %>% 
  tally() %>% 
  mutate(perc = round(n/sum(n)*100, 2)) %>% 
  arrange(desc(n))
```
Lets make each landuse category into a variable with pivot_wider() function. Some of the categories should perhaps be merged 

**Changes were made to this code-chunk**
```{r}
# m_vuln <- master_sp %>%
#   st_drop_geometry() %>%
#   filter(Type == "Burial Mound" | Type == "Extinct Burial Mound") %>% 
#   mutate(n=1) %>% 
#   pivot_wider(names_from = LU_Around, values_from= n, values_fill = list(n = 0)) %>% 
#   rename(Annual = 'Annual agriculture', Perennial = 'Perennial agriculture', OtherLU = Other)

# The variable LU_Around still does not exist

m_vuln <- master_sp %>%
  st_drop_geometry() %>%
  filter(Type == "Burial Mound" | Type == "Extinct Burial Mound") %>%
  mutate(n=1) %>%
  pivot_wider(names_from = LU_Arnd, values_from= n, values_fill = list(n = 0)) %>%
  rename(Annual = 'Annual agriculture', Perennial = 'Perennial agriculture', OtherLU = Other)
```

It might be a good idea to merge the small categories into larger ones, especially where is similar relationship (Annual and Perennial, Urban and Other)
```{r}
m_vuln <- m_vuln %>% 
  mutate(Annual = Annual + Perennial, 
         OtherLU = Urban +  OtherLU) %>% 
  dplyr::select(-one_of('Urban', 'Perennial'))
  
```

# Eliminate unnecessary columns

```{r}
m_vuln <- m_vuln %>% 
  dplyr::select(-one_of('TopoID', 'Note'))
```

# Creating 'Robbed' column
I want to see whether mound getting looted variable depends on any of the distance or landuse independent variables.

**Changes were made to this code-chunk**
```{r}
# levels(factor(m_vuln$PrincipalSourceOfImpact))
levels(factor(m_vuln$PrncSOI))

# m_vuln <- m_vuln %>%
#   mutate(Robbed = str_extract(PrincipalSourceOfImpact, "Loot")) %>%
#   mutate(Robbed = case_when(is.na(Robbed) ~ "No",
#                             Robbed == "Loot" ~ "Yes"))

# The variable PrincipalSourceOfImpact does not exist yet 

m_vuln <- m_vuln %>%
  mutate(Robbed = str_extract(PrncSOI, "Loot")) %>%
  mutate(Robbed = case_when(is.na(Robbed) ~ "No",
                            Robbed == "Loot" ~ "Yes"))

```

# Add distances to town and Bulgarian border in kms
if it is easier for the logit output...

**Changes were made to this code-chunk**
```{r}
m_vuln$distBGkm <-m_vuln$distBG/1000 
# m_vuln$distTownkm <-m_vuln$distTown/1000 
# distTwn instead of distTown
m_vuln$distTownkm <-m_vuln$distTwn/1000 
```

# Condition 
We need to streamline a bit the Condition variable, clarifying NAs and recoding number 6 as it should be 1-5 Likert scale. Beware that this code will clear uncertainty such as 3? or 2? , where condition was hard to gauge in the field.

**Changes were made to this code-chunk**
```{r}
# This newly added chunk reclassifies the values in master$Condition, which means the following effect analysis needs to be adjusted. See if it is easier to leave as was with 0 marking NAs.

# levels(factor(m_vuln$Condition))
levels(factor(m_vuln$Conditn))

# m_vuln <- m_vuln %>%
#   mutate(Condition = str_extract(Condition, "\\d")) %>%
#   mutate(Condition = case_when(Condition == 0 ~ "NA",
#                                Condition == 6 ~ "5",
#                                Condition != 0 ~ Condition))

# The variable Condition does not exist in the when the data is piped into the first mutate() function - it was called Conditn at that point

m_vuln <- m_vuln %>%
  mutate(Condition = as.character(str_extract(Conditn, "\\d"))) %>%
  mutate(Condition = case_when(Condition == 0 ~ "NA",
                               Condition == 6 ~ "5",
                               Condition != 0 ~ Condition))

m_vuln$Condition <- as.numeric(m_vuln$Condition)
unique(m_vuln$Condition)
```

# Print out the result
**Changes were made to this code-chunk**
```{r}
# write_csv(m_vuln, "../output_data/vulnerability.csv")
# The file-path of the code above is does not work. instead, this should work:
write_csv(m_vuln, "../data/vulnerability.csv")
```


**I did not test this part of the code**
# Internal Review for Adela ONLY -  SKIP UNTIL LOGIT on line 178
Lets review the Condition. It, too, might need some aggregation of categories (e.g. 1 and 2), but for now I am leaving it in the original state.
```{r}
# m_effect <- m_effect %>%
#   mutate(effect = str_extract(Condition, "[0-9]"))

m_vuln %>%
  filter(!is.na(Condition)) %>% # 90 features have 0 - No observation in Condition
  group_by(Type, Condition) %>% 
  tally()
```

## Final review of Condition - sanity checks with photographs! 
Lets review these features where effect/condition is marked as 0 - No observation possible. Are these typos or truly NAs? Well, they do look like NAs, so lets' exclude them in the future. We might also want to focus on mounds only
```{r}
master %>%
  filter(effect == 0 & Type == "Burial Mound")
```
Mound 9548 should have effect == 6, given the pasture landuse. All others should stay as NAs
```{r}
master %>%
  filter(effect == 0) %>% 
  filter(Type == "Extinct Burial Mound" | Type == "Uncertain Mound")
```
All but 9626 should have effect == 6


## Another way of prepping Condition if reading in another dataset

Let's check the condition of mounds depending on landuse. 
- select only mounds
- collate effect into 2-3 categories

```{r , eval=FALSE, echo = FALSE}
mounds2 <- masterall %>% 
  mutate(effect = case_when(effect == "1" ~ "2",
                     effect == "6" ~ "5",
                     effect %nin% c("1","6") ~ effect)) %>% 
  filter(grepl("Mound", Type)) %>% 
  rename(distTown = NEAR_DIST, TownX = NEAR_X, TownY = NEAR_Y)

mounds2 %>% 
  filter(effect != 0) %>% 
  group_by(effect) %>% 
  tally()

```

**I did test this part of the code**
# Logit model - basically reproducing Eftimoski's logit from Kazanlak
```{r}
library(haven)
library(MASS)
require(ordinal)

```

```{r logit}
# Using polr() function from the MASS library 
logittable1 <- polr(factor(Condition) ~ Annual + Scrub + Pasture + Forest + Robbed + distTownkm + distBGkm, data = m_vuln, Hess = TRUE)

logittable1

```

```{r probit}
probit<-polr(factor(Condition) ~ Annual + Scrub + Pasture + 
    Forest + Robbed + distTownkm + distBGkm, data = m_vuln)
probit

```

Lets try plain glm
**This should not work. I am not sure why it does - perhaps the model dichotomizes the condition variable?**
```{r}
# test<-glm(factor(Condition) ~ Annual + Scrub + Pasture + Forest + Robbed + distTown, family= "binomial", data = m_vuln) 
# summary(test)

# Same model after correcting the variable names
test<-glm(factor(Condition) ~ Annual + Scrub + Pasture + Forest + Robbed + distTownkm, family= "binomial", data = m_vuln) 
summary(test)
```

# Another attempt at a model (Rebecca)
I am not sure why you chose to split the land use variable up into separate categories, but I cannot think of any statistical justification for doing so in the model.  

While I do not have domain-specific knowledge about the subject, I have attempted to create a model I think makes more statistical sense below (based on the hypotheses written in this markdown)

# Creating a dataframe without splitting up LU_Arnd

**Merging the categories Annual and Perennial as well as Urban and Other.**

```{r}
# Creating a new dataframe from master_sp
modified_vuln <- master_sp

# Re-leveling the factor to merge categories
levels(modified_vuln$LU_Arnd) # How many levels are there?
modified_vuln$LU_Arnd[1:10] # Having a look at the variable
new_levels <- c("Perennial", "Forest", "Urban", "Pasture", "Perennial", "Scrub", "Urban") # Making a list of new levels (in order)
levels(modified_vuln$LU_Arnd) <- new_levels # Re-naming the levels
modified_vuln$LU_Arnd[1:10] # Testing if it worked

```
There is actually a statistics method for figuring out which categories in a variable it would be valid to combine - I think Martin did something like this for the condition variable in the report you sent me. It has been a while since I have done it myself, but I could look into it if you want. 
Also, for the combined variables, I have used the same names as you did after you split LU_Arnd up, thoug I am not sure of informative they were (maybe we could rename the combined annual and perennial variables to something like "agriculture"?).

**Creating a "Robbed" variable**
This is basically just copying code from earlier

```{r}
modified_vuln <- modified_vuln %>%
  mutate(Robbed = str_extract(PrncSOI, "Loot")) %>%
  mutate(Robbed = case_when(is.na(Robbed) ~ "No",
                            Robbed == "Loot" ~ "Yes"))
```

**Changing the unit of the distance variables**
Again, I will be borrowing your code for this one. 

```{r}
modified_vuln$distBGkm <-modified_vuln$distBG/1000 
modified_vuln$distTownkm <-modified_vuln$distTwn/1000 
```

**Clarifying condition**
Again, I am using your code. 
```{r}
levels(factor(modified_vuln$Conditn))

modified_vuln <- modified_vuln %>%
  mutate(Condition = as.character(str_extract(Conditn, "\\d"))) %>%
  mutate(Condition = case_when(Condition == 0 ~ "NA",
                               Condition == 6 ~ "5",
                               Condition != 0 ~ Condition))

modified_vuln$Condition <- as.numeric(modified_vuln$Condition)
unique(modified_vuln$Condition)
```

**Elliminate columns that are not useful for the analysis**
Again, using your code from earlier.

```{r}
modified_vuln <- modified_vuln %>% dplyr::select(-one_of('TopoID', 'Note'))

```

**Printing the result**

```{r}
write_csv(modified_vuln, "../data/modified_vulnerability.csv")
```

In hindsight, it would probably have been easier and faster to just modify m_vuln instead of going back to master_sp, but what is done is done. 

# Running the model 
Variables: Land-use, distance to boarder, distance to town, Robbed?, Size? 

